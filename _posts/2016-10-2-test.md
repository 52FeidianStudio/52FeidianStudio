##认识redux

redux 是 facebook 提出的 flux 架构的一种优秀实现，用于管理单一数据流，和react配合起来使用简直酷到爆

-------------------------

[TOC]

###redux的优缺点
####优点
可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），由于是单一的 state tree ，调试也变得非常容易
只是 Redux 限定一个应用只能有一个 Store。单一 Store 带来的好处是，所有数据结果集中化，操作时的便利，只要把它传给最外层组件，那么内层组件就不需要维持 state，全部经父级由 props 往下传即可。子组件变得异常简单
####缺点
###Action
**action**是把数据从应用传到 store 的有效载荷，它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。

Action 是一个普通对象。
redux约定 Action 内使用一个字符串类型的 type 字段来表示将要执行的动作。
```javascript
  {
    type: 'ADD_ITEM'
    text: '我是Berwin' //或者存放一些其他想要的操作
  }
```
###store
Store 有以下职责：
- 维持应用的 state；
- 提供 getState() 方法获取 state；
- 提供 dispatch(action) 方法更新 state；
- 通过 subscribe(listener) 注册监听器。
   
###reducer
Reducer 是一个普通的回调函数。
当它被Redux调用的时候会为他传递两个参数 State 和 Action 。
Reducer会根据 Action 的type来对旧的 State 进行操作。返回新的State。
```javascript
let reducer = (state = [], action) => {
  switch (action.type) {
    case ADD_ITEM:
      return [createItem(action.text), ...state]

    default:
      return state
  }
}
```
> 不要修改 state 。
>- 在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。
>- 如果没有旧的State，就返回一个initialState，这很重要！！！

>如果在default或没有传入旧State的情况下不返回旧的State或initialState。。。那么当前的State会被重置为undefined！！
```javascript
// currentState 是当前的State，currentReducer 是当前的Reducer
currentState = currentReducer(currentState, action);
```
上面是一部分核心源码

###combineReducers
combineReducers 生成了一个类似于Reducer的函数。为什么是类似于，因为它不是真正的Reducer，它只是一个调用Reducer的函数，只不过它接收的参数与真正的Reducer一模一样~
```javascript
function combineReducers(reducers) {

  // 过滤reducers，把非function类型的过滤掉~
  var finalReducers = pick(reducers, (val) => typeof val === 'function');

  // 一开始我一直以为这个没啥用，后来我发现，这个函数太重要了。它在一开始，就已经把你的State改变了。变成了，Reducer的key 和 Reducer返回的initState组合。
  var defaultState = mapValues(finalReducers, () => undefined);

  return function combination(state = defaultState, action) {
    // finalReducers 是 reducers
    var finalState = mapValues(finalReducers, (reducer, key) => {

      // state[key] 是当前Reducer所对应的State，可以理解为当前的State
      var previousStateForKey = state[key];
      var nextStateForKey = reducer(previousStateForKey, action);

      return nextStateForKey;      
    });

    // finalState 是 Reducer的key和stat的组合。。
  }
}
```
从上面的源码可以看出，combineReducers 生成一个类似于Reducer的函数 combination 。

当使用combination的时候，combination会把所有子Reducer都执行一遍，子Reducer通过action.type 匹配操作，因为是执行所有子Reducer，所以如果两个子Reducer匹配的action.type是一样的，那么都会成功匹配。